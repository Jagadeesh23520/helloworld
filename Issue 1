Ah ðŸ”¥ youâ€™ve described the classic confusion with ThreadPoolExecutor behavior.
Letâ€™s carefully unpack why you saw that maxPoolSize did not kick in when you expected.


---

ðŸ”¹ Your Config Recap

sqs.config.max.message = 5
sqs.config.core.poolsize = 3
sqs.config.max.poolsize = 5
sqs.config.queue.capacity = 5
sqs.config.wait.timeout = 3

Core threads: 3

Extra threads (max): 2 more possible

Queue size: 5

Batch poll size: 5 messages at once



---

ðŸ”¹ What Happened in Your Scenario

1. Step 1 â€” Core messages posted (11 messages)

First 3 â†’ run immediately on 3 core threads.

Next 5 â†’ go into the queue (queue has room).

Remaining 3 (total 11 âˆ’ 3 âˆ’ 5 = 3) â†’ queue now full, so new threads should be created (up to maxPoolSize = 5).




ðŸ‘‰ But you observed that new threads did not start, and only 3 kept running.


---

2. Step 2 â€” On-demand messages posted (20 messages)

Executor still sees queue has tasks waiting.

By default, ThreadPoolExecutor prefers queueing over growing threads.

So instead of using maxPoolSize, it keeps filling the queue.

Only when both:

corePoolSize threads are busy AND

queue is completely full,

then and only then â†’ pool grows beyond core.






---

ðŸ”¹ Why Your Threads Didnâ€™t Grow

In Springâ€™s ThreadPoolTaskExecutor, the queue used is typically a LinkedBlockingQueue (unbounded by default, but you set queueCapacity=5).

Even with bounded queues, the executorâ€™s default policy is:


> Always fill the queue before creating new threads beyond corePoolSize.



So:

As long as queue has space, maxPoolSize is ignored.

Thatâ€™s why all 20 on-demand messages + remaining core messages just waited.



---

ðŸ”¹ Visualizing With Your Numbers

Core: 3 running

Queue capacity: 5 â†’ filled quickly

Remaining tasks: get stuck in queueing instead of scaling to 5 threads


So effectively:

Only 3 threads are actively working most of the time.

maxPoolSize is sitting unused.



---

ðŸ”¹ âš¡ Solution: Force MaxPoolSize to Work

If you want maxPoolSize threads to actually get used:

1. Set small queueCapacity (0 or 1)

Forces the executor to create threads instead of just queueing.


sqs.config.queue.capacity: 0


2. Use CallerRunsPolicy / Custom Rejection Handler

When queue fills, you can push back to the caller or fail fast.



3. Tune max.message carefully

If you fetch 5 at a time but can only process 3 concurrently, 2 always wait.





---

âœ… Answer in one line:
Your maxPoolSize was not used because ThreadPoolExecutor always prefers queueing tasks over creating new threads; with queueCapacity=5, it happily queued tasks instead of growing beyond 3 core threads. If you want to actually use maxPoolSize=5, reduce queueCapacity to 0â€“1.


---

ðŸ‘‰ Do you want me to suggest an optimal configuration for your case (11 core + 20 on-demand messages, DB taking 10s each), so priority/on-demand both get fair thread allocation?

